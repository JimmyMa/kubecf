#!/usr/bin/env ruby
##
# Given a path to a file holding a list of events as generated by the
# `upwatch` tool, convert the events found in the file into a diagram
# visualizing their sequencing. The result is written to stdout. The
# diagram/image format is SVG (scalable vector graphics).

# Usage:
# sequence /path/to/event/file > /path/to/svg/result

def main()
    emit *(process ingest cmdline)
end

def cmdline
  usage if ARGV.length != 1
  ARGV.first
end

def usage
  STDERR.puts "Usage: sequence /path/to/event/file"
  exit 1
end

def ingest (path)
  File.read(path).split("\n")
end

def process (lines)
  base   = lines.first.split()[1].to_i
  xmax   = 0
  height = 20

  note = {}
  s    = {}

  # I. Separate events per igroup, and zero timestamps to the base.
  #    Keep the largest timestamp (= youngest/last event) per igroup.
  lines.each do |line|
    (_unused_, stamp, state, ig) = line.split()
    x = stamp.to_i - base
    note[ig] = x
    xmax = x
    s[ig] ||= []
    s[ig] << [ state, x, height ]
  end

  # s    : ig -> list (tuple(state x h))
  # note : ig -> (max-x)

  # II. Collect igroup and last timestamp, for sorting.
  gs = []
  s.each { |key, value| gs << [ note[key], key ] }

  # Generate final sequencing per igroup for diagram emission
  dia = {}
  y = 0
  gs.sort.each do |el|
    ig = el[1]
    y += height

    # Get actions, add a fake for closure of true last event.
    actions = s[ig]
    actions << [ "", note[ig] + 5, 0 ]

    note[ig] = y

    # Compute location and dimensions of the events. The width is
    # computed against the following event. Height is fixed. Vertical
    # location increments from igroup to igroup. Each round actually
    # operates on the previous element, using the current for the
    # widrh calculation.

    dia[ig] = []
    prev = actions.first
    actions[1,actions.length-1].each do |now|
      (state, x, h) = prev
      w = now[1] - x
      dia[ig] << [ state, x, y, w, h ]
      prev = now
    end
  end

  # dia  : ig -> list (tuple(state x y w h))
  # note : ig -> y

  [ dia, note, xmax, y, height ]
end

def emit(dia, note, xmax, ymax, height)
  ehead xmax, ymax, height

  dia.keys.sort.each do |ig|
    e = nil
    dia[ig].each do |el|
      (_, x, _, w, _) = el
      ebox *el
      e = x + w
    end
    etext ig, e+2, height/2 + note[ig]
  end
  etail
end

def ehead (xmax, ymax, height)
  xmax += 100        # give space to the (last) text for ig's, to the right
  ymax += 2 * height # give space to the last row, down
  puts "<svg width='#{xmax}' height='#{ymax}' xmlns='http://www.w3.org/2000/svg'>"
  ebox "<BG>", 0, 0, xmax, ymax
end

def etext(text, x, y)
  puts "<text x='#{x}' y='#{y}'>#{text}</text>"
end

def etail
  puts "</svg>"
end

def ebox(text, x, y, w, h)
  c = color text
  puts "<rect x='#{x}' y='#{y}' width='#{w}' height='#{h}' style='fill:#{c};stroke:black'/>"
  #etext text, x, y if text
end

def color(text)
  return "lightblue" if text =~ /Init:.*/
  return "yellow"    if text =~ /Run:.*/
  {
	"<BG>"                  => "white",
	"Pending"               => "yellow",
	"PodInitializing"       => "yellow",
	"ContainerCreating"     => "yellow",
	"Error"                 => "red",
	"CrashLoopBackOff"      => "orange",
	"Init:CrashLoopBackOff" => "orange",
	"Ready"                 => "green",
	"Completed"             => "green",
	"Terminating"           => "orange"
  }[text]
end

main
exit
